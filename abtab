#!/bin/bash

# Script that runs abtab.

# BASH SYNTAX
# - variable expansion
#   - when referencing a variable var (like "$var"), you ask Bash to replace it with its value
#   - curly braces help clarify where the variable name starts and ends
#   - when the variable is an array, curly braces are required to correctly expand all elements
#     - example: "${my_arr[@]}" 
#       - expands to all (hence the '@') elements of my_arr, separating them by the  
#         first character of the Internal Field Separator (IFS, which is a space by default)  
#       - the double quotes ("...") ensure that each array element is treated as a single word, 
#         preserving any spaces or special characters within the element
#   - it is good practice to use double quotes around variables ("$my_var"), unless you
#     specifically want to allow word splitting or glob expansion 
# - $@ is a special variable that reflects
#   - in the script (outside of any function): all args passed to the script via the terminal
#   - within a function: all args passed to that function
#     - if a shift command is used inside a function, it modifies the positional parameters ($1, $2, ...),
#       and as a result, the value of $@ (and $*) also changes
# - command substitution with $(...) 
#   - the $(...) syntax captures the output of the command or function. This means that 
#     the entire output of what is inside the parentheses is treated as a single string
# - indirect expansion
#   - indirect expansion allows referencing the value of a variable whose name is stored
#     in another variable
#     my_var="Hello, World!"
#     varname="my_var"
#     echo "$varname"        # direct reference; output: "my_var"
#     echo "${!varname}"     # indirect expansion; output: "Hello, World!""
#
# - get full path to <file>.<ext> in pwd with "$(pwd)""/<file>.<ext>"
# - get parent of my_path with $(dirname "$my_path")"/"
# - print complete list with echo "${my_list[@]}"


# 0. GLOBAL VARIABLES
# a. Set manually
TOOLS_DESC=(
	"analyser|Analyse" 
	"converter|Convert" 
	"tabmapper|Map"
	"transcriber|Transcribe"
)
# Each row in an OPTS_VALS array contains the following comma-separated elements
# [0] short opt
# [1] long opt
# [2] values
# [3] long values (or "") 
# [4] default value (or "")
# [5] opt values catch-all (or "")
# [6] help text
# [7] additional help text
# NB1 Identical short opts can have different long opts;
#     identical long opts always have the same short opt
# NB2 opts-vals pairs must also be class fields in CLInterface Java class (<OPT> = "<val>")
#     and parser args in transcriber.py
format="-r|--format|y n||y||Process tablature format|"
file="-f|--file|*.tc *.tbp *.xml *.mei||n/a|file|Process only the given file; options|"
help="-h|--help|||n/a||Display this help message|"
OPTS_WITHOUT_VAL=("-h" "--help")
ANALYSER_OPTS_VALS=(
	"-a|--analysis|VC VR VRO||n/a|analysis|Analysis; options|"
	"$file" 
	"$help"
)
CONVERTER_OPTS_VALS=(
	"$help"
)
TABMAPPER_OPTS_VALS=(
	"-o|--ornamentation|y n||y||Include ornamentation|"
	"-s|--score|y n||n||Show as score|"
	"-t|--tablature|t b|top bottom|b||Placement of the tablature; options|"
	"-d|--duration|y n||n||Complete note durations|"
#	"$format"
	"$file"
	"$help"
)
# custom, dlaute: irrelevant are -y, -o, -v // user-chosen is -f
# custom, plaute: irrelevant is -y // user-chosen are -k, -m, -o, -v, -f 
TRANSCRIBER_OPTS_VALS=(
	"-u|--tuning|F F6Eb G G6F A A6G i||i|tuning|Tuning; options|"
#	"-u|--tuning|F F6Eb G G6F A A6G i||i (as in input file) if provided; else G|tuning|Tuning; options|"
	"-k|--key|-5 -4 -3 -2 -1 0 1 2 3 4 5 i||i|key|Key; options|"
	"-m|--mode|0 1|major minor|0||Mode; options|"
	"-s|--staff|s d|single double|d||Staff; options|"
	"-t|--tablature|y n||y||Include tablature|"
	"-y|--type|FLT ILT SLT GLT i||i|type|Tablature type; options|"
#	"-y|--type|FLT ILT SLT GLT i||i (as in input file) if provided; else FLT|type|Tablature type; options|"
	"-l|--style|p d|polyphonic diplomatic|p||Transcription style; options|"
	"-o|--model|N-bwd-thesis-int-4vv N-fwd-thesis-int-4vv N-bwd-thesis-int-3vv||N-bwd-thesis-int-4vv|model|* Trained model; options|"
	"-v|--verbose|y n||n||* Verbose|"
	"-c|--custom|dlaute plaute user||n/a|custom|Use customisation (pre-defined set of options); options|"
#	"${format/Process/* Process}" # insert asterisk + space
	"$file"
	"$help"
)

# b. Set automatically
TOOLBOX=$(basename "$0")
DEV=false
if [[ "$TOOLBOX" == 'abtab-dev' ]]; then
	TOOLBOX='abtab'
	DEV=true
fi

unset TOOL
unset OPTS_VALS
unset OPTS
unset OPTS_LONG
unset VALS_DEFAULT


# 1. FUNCTIONS
_get_column() {
	# Gets the column at the given index from the given array.

	local arg_col="$1"
	shift # shifts the args to skip the first
	local arg_opts_vals_array=("$@") # reconstructs array from remaining args
	local res=()

	for row in "${arg_opts_vals_array[@]}"; do
		# Split the row into an array
		IFS='|' read -r -a row_array <<< "$row"
		res+=("${row_array[$arg_col]}")
	done

	# Echo the result array as a space-separated string
    echo "${res[@]}"
}


_array_contains() {
	# Checks if the given array contains an exact match of the given string.

	local val="$1"
	shift # shifts the args to skip the first
	local array=("$@") # reconstructs array from remaining args

	for item in "${array[@]}"; do
		if [[ "$item" == "$val" ]]; then
			return 0
		fi
	done

	return 1
}


_show_help() {
	local arg_tool="$1"

	if [ "$arg_tool" == "all" ]; then
		local tools=($(_get_column 0 "${TOOLS_DESC[@]}"))
		local descs=($(_get_column 1 "${TOOLS_DESC[@]}"))
		echo "Usage: $TOOLBOX [tool] [options]"
    	echo
    	echo "Tools:"
		for i in "${!TOOLS_DESC[@]}"; do
			printf "%-30s %-20s\n" "  ${tools[i]}" "${descs[i]}"
    	done
    	echo
    	echo "Use '$TOOLBOX [tool] -h' to see options for each tool"
	else
    	echo "Usage: $TOOLBOX $TOOL [options]"
		echo
    	echo "Options for $TOOL:"
		for row in "${OPTS_VALS[@]}"; do # str
			IFS='|' read -r -a row_array <<< "$row" # array
			local short_opt="${row_array[0]}"
			local long_opt="${row_array[1]}"
			local vals="${row_array[2]}"
			local long_vals="${row_array[3]}"
			local default="${row_array[4]}"
			local vals_catch_all="${row_array[5]}"
			local help_text="${row_array[6]}"
			local add_help_text="${row_array[7]}"
			
			if [[ ! ("$short_opt" == "-r" && "$TOOL" == "tabmapper") ]]; then
				# Form of the string to output (parts between {curly brackets} are optional):
				# short_opt, long_opt <choice_text> \t help_text{options_text} {default_text}{. add_help_text}
				# - choice_text: only two values (a); more than two values (b) 
				#   (a) "<short_val1|short_val2>"
				#   (b) "<catch_all>"
				# - options_text: only two values (but not 'y/n') (a); more than two values (b)
				#   (a) "; options long_val1 (short_val1) or long_val2 (short_val2)"
				#       e.g., 
				#       "; options major (0) or minor (1)"
				#   (b) "; options [short_val1, ..., short_valn]"
				#       e.g.
				#       "; options [-5, ..., 5]"
				# - default_text
				#   "(default: short_val)"   
				#
				# Determine choice_text
				IFS=' ' read -r -a vals_arr <<< "$vals"
				local num_vals="${#vals_arr[@]}"
				local choice_text=""
				if [[ "$num_vals" -eq 2 ]]; then
					choice_text="<$(echo "$vals" | tr ' ' '|')>"
				else
					if [[ "$short_opt" == "-h" ]]; then
						choice_text=""
					else 
						choice_text="<$vals_catch_all>"
					fi
				fi

				# Determine options_text
				local options_text=""
				if [[ "$help_text" == *"options" ]]; then # help_text ends with 'options'
					if [[ "$num_vals" -eq 2 && !( "$vals" == "y n" || "$vals" == "n y") ]]; then
						IFS=' ' read -r -a long_vals_arr <<< "$long_vals"
						options_text=" ${long_vals_arr[0]} (${vals_arr[0]}) or ${long_vals_arr[1]} (${vals_arr[1]})"
					else 
						options_text=" [$(echo "$vals" | sed 's/ /, /g')]"
					fi
				fi

				# Determine default_text
				local default_text=""
				if [[ -n "$default" && "$default" != "n/a" ]]; then
					default_text=" (default: $default)"
				fi
#				# Prepend add_help_text with period and space
#				if [[ ! "$add_help_text" == "" ]]; then
#					add_help_text=". $add_help_text"
#				fi

				# Combine
				local options="  $short_opt, $long_opt $choice_text"
				local help_text="$help_text""$options_text""$default_text" #"$add_help_text"
				max_help_len=75
				# If help_text requires multiple lines 
				if [[ ${#help_text} -gt $max_help_len ]]; then
					# Use fold to wrap the help text
					local wrapped_help=$(echo "$help_text" | fold -s -w $max_help_len)

					# Print $options with the first line of help text
					printf "%-30s %-20s\n" "$options" "$(echo "$wrapped_help" | head -n 1)"

					# Print the remaining lines of the wrapped help text, aligned to start at column 31
					echo "$wrapped_help" | tail -n +2 | while IFS= read -r line; do
						printf "%-30s %-20s\n" "" "$line"
					done
				# If not
				else
					printf "%-30s %-20s\n" "$options" "$help_text"
				fi
			fi
		done
		if [[ "$TOOL" ==  "transcriber" ]]; then
			echo "* Applies only if transcription style is polyphonic"
		fi
    fi
}


source_filtered() {
	# Filters out empty lines and removes carriage returns (\r)
	# from all lines before sourcing the given file. The file
	# itself is not affected.

	local file="$1"
	source <(grep -v '^[[:space:]]*$' "$file" | tr -d '\r')
}


check_first_arg() {
	# Checks the first argument given to the script, which should be
	# '-h', '--help', or a valid tool.

	# No args provided or -h/--help
	if [[ $# -eq 0 || "$1" == "-h" || "$1" == "--help" ]]; then
		_show_help "all"
	    exit 1
	# Invalid tool
	elif ! _array_contains "$1" $(_get_column 0 "${TOOLS_DESC[@]}"); then
		echo "$TOOLBOX: unknown tool -- $1"
		_show_help "all"
		exit 1
	else
		TOOL="$1"
		shift # make the next arg $1
	fi
}


set_global_vars() {
	# Sets the global variables for the given tool.

	local arg_tool="$1"
	# Set appropriate opts_vals
	case "$arg_tool" in
		analyser)
			OPTS_VALS=("${ANALYSER_OPTS_VALS[@]}")
			;;
		converter)
			OPTS_VALS=("${CONVERTER_OPTS_VALS[@]}")
			;;
		tabmapper)
			OPTS_VALS=("${TABMAPPER_OPTS_VALS[@]}")
			;;
		transcriber)
			OPTS_VALS=("${TRANSCRIBER_OPTS_VALS[@]}")
			;;
	esac

	# Create options arrays
	OPTS=($(_get_column 0 "${OPTS_VALS[@]}"))
	OPTS_LONG=($(_get_column 1 "${OPTS_VALS[@]}"))
	VALS_DEFAULT=($(_get_column 4 "${OPTS_VALS[@]}"))
}


parse_options() {
	# Populate opts_str and opts_long_str
	opts_str="$(_make_options_str "${OPTS[@]}")"
	opts_long_str="$(_make_options_str "${OPTS_LONG[@]}")"

	# Positional arguments are the inputs passed to a script or function
	# Positional parameters ($1, $2, ...) are how the script or function accesses those arguments
	# NB Within this function, $@ reflects all args given to this function
	#
	# getopt rearranges and normalises arguments. Execute getopt to parse $@ using the
	# specified short and long options. Store result in $PARSED, with any positional
	# arguments appearing after a '--'. Example:
	# $@      : transcriber -k -2 -y GLT
	# $PARSED : -k '-2' -y 'GLT' -- 'transcriber'
	PARSED=$(getopt --options="$opts_str" --longoptions="$opts_long_str" --name "$0" -- "$@")
	if [[ $? -ne 0 ]]; then # if the exit status of the last command (i.e., `getopt`) is not 0
		_show_help ""
		exit 1
	fi

	# Update positional parameters ($@, $1, $2, ...) with the parsed and normalised
	# arguments in $PARSED. After this, $@ reflects the parsed and normalised arguments,
	# with any positional arguments appearing after a '--'.Example:
	# $@      : -k -2 -y GLT -- transcriber
	eval set -- "$PARSED"

	echo "$@"
}


_make_options_str() {
	# Creates a string of all options in the given list. By default, all options
	# are followed by a colon (indicating that they require a value); only those
	# in OPTS_WITHOUT_VAL are not. Long options (but not the last) are separated 
	# separated by a comma.
	#
	# Example inputs and outputs
	# -a -b -c -h --> a:b:c:h
	# --longa --longb -- longc --help --> longa:,longb:,longc:,help

	local arg_options=("$@") # reconstructs array from args
	local res=""

	# Check if the given list contains long or short options
	local is_long=false
	if [[ "${arg_options[1]}" == --* ]]; then # if starts with two hyphens
		is_long=true
	fi
	local unique_options=()
	for o in "${arg_options[@]}"; do
		local o_no_dashes="${o##*-}" # remove all leading hyphens
		if ! _array_contains "$o" "${unique_options[@]}"; then
			res+="$o_no_dashes"
			unique_options+=("$o")
			# Add colon (if appropriate)
			if ! _array_contains "$o" "${OPTS_WITHOUT_VAL[@]}"; then
				res+=":"
			fi
			# Long option: add comma (not after the last, which is always '--help')
			if "$is_long" && [[ "$o" != "--help" ]]; then
				res+=","
			fi
		fi
	done

	echo "$res"
}


expand_args() {
	local parsed_args_str="$@" # str
	local delimiter=" -- "
	local trimmed_delimiter="--"

	# Get optional and positional args
	local optional="${parsed_args_str%%$delimiter*}""$delimiter" # everything up to delimiter + delimiter
	local positional="${parsed_args_str#*$delimiter}" # everything after delimiter
	optional=($optional) # arr

	# If there is a customisation  
	if _array_contains "-c" "${optional[@]}" || _array_contains "--custom" "${optional[@]}"; then
		# Determine customisation
		local CUSTOMISATION_=''
		for i in "${!optional[@]}"; do
			if [[ "${optional[i]}" == "-c" || "${optional[i]}" == "--custom" ]]; then
				CUSTOMISATION_="${optional[i+1]}"
				break
			fi
		done

		# Get custom args and parse them
		local cst="${!CUSTOMISATION_}" # indirect expansion evaluates to "$<custom> from config.cfg
		local parsed_args_custom=($(parse_options "$cst")) # arr
		local parsed_args_custom_str="${parsed_args_custom[@]}" # str

		# Get optional custom args (there are no positional custom args)
		local optional_custom="${parsed_args_custom_str%%" --"*}" # everything before ' --'
		optional_custom=($optional_custom) # arr

		# Prune optional by removing -c/--custom and any args that are in optional_custom
		local optional_pruned=''
		for i in "${!optional[@]}"; do
			local curr="${optional[i]}"

			# If curr is the delimiter: break
			if [[ "$curr" == "$trimmed_delimiter" ]]; then
				break
			# If curr is an option or a flag (i.e., starts with a dash) and not a value
			elif [[ "$curr" == -* ]]; then
				# If curr is not -c/--custom and not defined in parsed_args_custom: add
				if ! ([[ "$curr" == "-c" || "$curr" == "--custom" ]] || _array_contains "$curr" "${optional_custom[@]}"); then
					optional_pruned+="$curr ${optional[i+1]} "
				fi
			fi
		done

		# Combine
		echo "$optional_pruned${optional_custom[@]}$delimiter$positional"
	# If there is no customisation
	else
		echo "$parsed_args_str"
	fi
}


populate_opts_and_vals_lists() {
	# Populates options_used and values_used by parsing the given args; in the process,
	# validates input vals (getopt has no built-in functionality to do this). If one
	# or more input values are incorrect, exits with an error.

	# Populate
	while true; do
		# $1 is the current option; $2 its value. The shift command
		# makes the next (shift) or second-next (shift 2) arg $1
		case "$1" in
			# End of the options; all subsequent arguments are positional arguments
			--)
				shift
				break
				;;
			# Help case
			-h|--help)
				_show_help ""
				exit 0
				;;
			# Remaining cases
			*)
				declare -a option_details
				_get_option_details "$1" option_details
				local vals_str="${option_details[2]}" # str
				IFS=' ' read -r -a vals <<< "$vals_str" # array

				# Validate option value or file type
				if [[ "$1" != "-f" && "$1" != "--file" ]]; then
					if ! _array_contains "$2" "${vals[@]}"; then
						# NB same layout as 'unknown option -- <opt>' message given by getopt
						echo ""$TOOLBOX": unknown value for option "${1##*-}" -- "$2""
						_show_help ""
						exit 1
					fi
				else
					local extension="*.${2##*.}" # wildcard (*) + extension
					if ! _array_contains "$extension" "${vals[@]}"; then
						# NB same layout as 'unknown option -- <opt>' message given by getopt
						echo ""$TOOLBOX": invalid file type -- "$extension""
						_show_help ""
						exit 1
					fi
				fi
				# All OK? Add to lists
				local short_opt="${option_details[0]}"
				options_used+=("$short_opt")
				values_used+=("$2")
				shift 2
				;;
		esac
	done
}


_get_option_details() {
	# Finds the row in OPTS_VALS that goes with the given opt and
	# assigns it to the declared array.
	
	local search_opt="$1"
	local -n result_array="$2"  # declare second arg as a nameref for the array

	for row in "${OPTS_VALS[@]}"; do # str
		IFS='|' read -r -a row_array <<< "$row" # array
		local short_opt="${row_array[0]}"
		local long_opt="${row_array[1]}"
		if [[ $short_opt == "$search_opt" || $long_opt == "$search_opt" ]]; then
			result_array=("${row_array[@]}")
			return 0
		fi  
	done

	return 1
}


create_cli_args() {
	# Converts the CLI opts (o) and vals (v) into a string of one of 
	# the following formats 
	# Python case: "-o1 v1 -o2 v2 -o3 v3"
	# Java case:   "-o1 v1,-o2 v2,-o3 v3"

	local arg_options_used=("${!1}") # use indirect expansion to access array
	local arg_values_used=("${!2}") # use indirect expansion to access array
	local arg_ignore_opts=("${!3}") # use indirect expansion to access array	
	local arg_suff=","
	# Python case: suffix is space
	if [[ $4 == true ]]; then
		arg_suff=" "
	fi
	local arg_sep=" "

	local args=""
	for i in "${!arg_options_used[@]}"; do
		local o="${arg_options_used[$i]}"
		local v="${arg_values_used[$i]}"
		if ! _array_contains "$o" "${arg_ignore_opts[@]}"; then
			args+="$o$arg_sep$v"
			# If not last element in $arg_options_used: add suffix 
			if [[ $i -lt $((${#arg_options_used[@]} - 1)) ]]; then
				args+="$arg_suff"
			fi
		fi
	done

	echo $args
}


# 2. SCRIPT CODE
# 0. Source config.cfg
#source_filtered "config.cfg"

# 1. Set paths
# Paths (unix-style) are read from config.cfg 
# DEV case: paths set every time this script is called (below)
if "$DEV"; then
	# Source config.cfg
	source_filtered "config.cfg"
	ROOT_PATH_="$ROOT_PATH" # from config.cfg
	LIB_PATH_="$LIB_PATH" # from config.cfg
# Real-world case: paths added once during installation (in install.sh)
else
	ROOT_PATH_=""
	LIB_PATH_=""
	# Source config.cfg 
	source_filtered "$LIB_PATH_""config.cfg"
fi
PYTHON_PATH="${LIB_PATH_}transcriber/py/"
# Create the class path
# NB Instead of creating the class path every time this script is
# called, it can also be created once, in install.sh. However, the
# former is more flexible as it enables addition of code to the 
# class path after installation (and it is very fast anyway (< 0.5s)).
# Check OS: Windows or Linux-like
is_win=true
if [[ ! (-n "$WINDIR" || "$os_type" == "CYGWIN"* || "$os_type" == "MINGW"* || "$os_type" == "MSYS"*) ]]; then
    is_win=false
fi
class_path=$($LIB_PATH_/cp.sh $LIB_PATH_ $is_win)

# 2. Check first argument provided, which must be -h/--help or a valid tool
check_first_arg "$@"

# 3. Set global vars
set_global_vars "$TOOL"

# 4. Parse args
# NB $@ is *not* updated inside parse_options() and retains its initial
#    value (all args passed to the script via the terminal)
parsed_args=($(parse_options "$@"))
parsed_args=($(expand_args "${parsed_args[@]}"))

# 5. Populate options_used and values_used with the parsed args
options_used=()
values_used=()
populate_opts_and_vals_lists "${parsed_args[@]}"

# 6. Call tool
# Join array elements into a string with space as delimiter
all_opts_str="${OPTS[*]}"
all_default_vals_str="${VALS_DEFAULT[*]}"

if [ "$TOOL" == "analyser" ]; then
	ignore_opts=("")
	args_str=$(create_cli_args "options_used[@]" "values_used[@]" "ignore_opts[@]" false)
	model_id="N-bwd-thesis-int-4vv"
	java -cp "$class_path" analysis.Analyser "$DEV" $model_id $args_str
elif [ "$TOOL" == "converter" ]; then
	ignore_opts=("")
	args_str=$(create_cli_args "options_used[@]" "values_used[@]" "ignore_opts[@]" false)
	java -cp "$class_path" tbp.editor.Editor "$DEV"
elif [ "$TOOL" == "tabmapper" ]; then
	ignore_opts=("")
	args_str=$(create_cli_args "options_used[@]" "values_used[@]" "ignore_opts[@]" false)
	java -cp "$class_path" tabmapper.TabMapper "$DEV" "$all_opts_str" "$all_default_vals_str" "$args_str"
elif [ "$TOOL" == "transcriber" ]; then
	ignore_opts=("-l")
	is_diplomatic=false
	for i in "${!options_used[@]}"; do
		if [[ "${options_used[i]}" == "-l" && "${values_used[i]}" == d* ]]; then
			is_diplomatic=true
			break
		fi
	done

	# Diplomatic
	if [[ $is_diplomatic == true ]]; then
		args_str=$(create_cli_args "options_used[@]" "values_used[@]" "ignore_opts[@]" true)
		python $PYTHON_PATH"transcriber.py" $args_str "$DEV" $ROOT_PATH_ $LIB_PATH_ $class_path
	# Polyphonic
	else
		args_str=$(create_cli_args "options_used[@]" "values_used[@]" "ignore_opts[@]" false)
		java -cp "$class_path" ui.UI "$DEV" "$all_opts_str" "$all_default_vals_str" "$args_str"
	fi
fi