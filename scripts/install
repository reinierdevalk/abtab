#!/usr/bin/env bash

# Script that installs abtab.
#
# NB: When editing this file with Sublime, set the line endings to Unix: 
#     View > Line endings > Unix
#
# Directories layout after installation
#
# ROOT_PATH_
# |-- data/
# |-- models/
# |-- templates/
#
# EXE_PATH/
# |-- abtab
#
# LIB_PATH/
# |-- docs/
# |   |-- CHANGELOG.md
# |   |-- README.md
# |-- lib/					# runtime code only
# |   |-- .venv/			# virtual environment for Python dependencies
# |   |-- <repo_1-n>		# Java repositories
# |   |-- classpath.sh
# |   |-- common.sh
# |-- scripts/
# |   |-- install
# |   |-- update
# |   |-- requirements.txt
# |-- config.cfg			# auxiliary files
# |-- paths.json
# |-- repositories.txt
# |-- VERSION


# 0. GLOBAL VARIABLES
# a. Set manually
BIN_DIR="bin/"
LIB_DIR="lib/"
SCRIPTS_DIR="scripts/"
EXAMPLES_DIR="examples/"
DOCS_DIR="docs/"
DATA_DIR="data/"
VENV_DIR=".venv/"
GIT_DIR=".git/"
VENV_SUBDIR_WIN="Scripts/"
VENV_SUBDIR_UNIX="bin/"
DATA_SUBDIRS=(
	"analyser/in/" "analyser/out/" 
	"converter/" 
	"tabmapper/in/tab/" "tabmapper/in/MIDI/" "tabmapper/out/" 
	"transcriber/diplomatic/in/" "transcriber/polyphonic/in/" 
	"transcriber/diplomatic/out/" "transcriber/polyphonic/out/"
)

ABTABNAME="abtab"
classpathfile="classpath.sh"
commonfile="common.sh"
configfile="config.cfg"
pathsfile="paths.json"
repositoriesfile="repositories.txt"
versionfile="VERSION"
requirementsfile="requirements.txt"
abtabfile="$ABTABNAME"
gitignorefile=".gitignore"

REPO_URL="https://github.com/reinierdevalk/"
TEMPLATE_PATTERN="template-params-"
# Placeholders must be the same as in abtab
RP_PLACEHOLDER="_RP_PLACEHOLDER_"
LP_PLACEHOLDER="_LP_PLACEHOLDER_"
GP_PLACEHOLDER="_GP_PLACEHOLDER_"

REMOVE_FROM_REPO=(
	"src" "test" ".git" ".settings" # folders 
    ".classpath" ".project" ".gitignore" # files
)
MODELS=(
	"N-fwd-thesis-int-4vv" 
	"N-bwd-thesis-int-4vv" 
	"D-bwd-thesis-int-4vv"
)

# b. Set automatically 
SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)""/" # the absolute path of the current script (.../scripts/)
REPO_PATH="$(cd "$SCRIPT_PATH/.." && pwd)""/" # the path holding scripts/
# From configfile
ROOT_PATH_=
LIB_PATH_=
EXE_PATH_=
GETOPT_PATH_=
# From commonfile
IS_WIN_=
PYTHON_=
# Created
BIN_PATH_ROOT=
LIB_PATH_ROOT=
SCRIPTS_PATH_ROOT=
EXAMPLES_PATH_ROOT=
DOCS_PATH_ROOT=
DATA_PATH_ROOT=
LIB_PATH_LIB=
VENV_PATH_LIB=


# 1. FUNCTIONS
convert_win_path() {
    #Normalizes a filesystem path for consistent cross-platform comparison.
    #
    # Parameters:
    # p (string): The input path to normalise. Can be in one of the following forms:
    # - macOS/Linux POSIX path: "/Users/<name>/dir_x/"
    # - Windows path: "C:/Users/<name>/dir_x/" or "C:\Users\<name>\dir_x\"
    # - Cygwin path: "/cygdrive/c/Users/<name>/dir_x/"
    #
    # Behavior:
    # - Converts backslashes (\) to forward slashes (/).
    # - Removes duplicate consecutive slashes.
    # - Ensures the path ends with a single trailing slash.
    # - On Cygwin, converts POSIX-style (/cygdrive/<drive>/) paths to Windows-style
    #   drive paths (e.g., "F:/path") using cygpath -m.
    #
    # Returns:
    # Normalised path as a string suitable for reliable string comparison.
    #
    # Example:
    # $ FILE_PATH_RAW="/cygdrive/f/research/computation/software/"
    # $ FILE_PATH=$(normalize_path "$FILE_PATH_RAW")
    # $ echo "$FILE_PATH"  # Output: "F:/research/computation/software/"

    local p="$1"
    cygpath -m "$p" 2>/dev/null || echo "$p"
}

handle_file() {
    local file="$1"
    local make_executable="$2"
    # If the file exists, handle it
    if [[ -f "$file" ]]; then
        # Remove any carriage returns
        # All line endings in a script called by bash must be Unix style ('\n') 
        # and not Windows style ('\r\n'), which cause the following error:
        # 
        #   ./<my_script>.sh: line <n>: $'\r': command not found
        #    
        # Any carriage returns ('\r') must therefore be removed.
        #
        # NB: Carriage returns can be avoided by creating the file in Sublime 4,
        # after adding the following in the right field at Preferences > Settings:
        #
        #   {
        #    "default_line_ending": "unix"
        #   }
        remove_carriage_returns "$file"

        # Make executable (if applicable)
        if [[ "$make_executable" == "true" ]]; then
            chmod +x "$file"
        fi
    # If not, return error
    else
        echo "File not found: $file."
        exit 1
    fi
}

remove_carriage_returns() {
    local file="$1"
    if grep -q $'\r' "$file"; then
        tr -d '\r' <"$file" >file.new && mv file.new "$file"
    fi
}

check_pathname() {
	# Checks that the given path name is not unset/empty, 
	# and that it ends with a slash.
	
	local pathname="$1"
	declare -n ref="$pathname" # nameref to the actual variable

	# Check that variable is set and non-empty
	if [[ -z "$ref" ]]; then
		echo "Error: $pathname is not set or empty." >&2
		exit 1
	fi

	# Ensure that variable ends with a slash
	if [[ "${ref: -1}" != "/" ]]; then
		ref="${ref}/"
	fi
}

is_critical_path() {
	local path="$1"

	# Empty or root
	[[ -z "$path" || "$path" == "/" ]] && return 0

	# Unix critical directories: start with /bin, /usr, /etc, /lib, /home
	if [[ "$path" == /bin* || "$path" == /sbin* || "$path" == /usr* || \
		  "$path" == /etc* || "$path" == /lib* || "$path" == /home* ]]; then
		return 0
	fi

	# Windows (Cygwin/Git Bash) critical directories: anything under /cygdrive/c
	if [[ "$path" == /cygdrive/c* ]]; then
		return 0
	fi

	return 1
}

read_reposfile() {
	# Reads a text file and returns an array containing its individual 
	# lines (including any trailing slash). Empty lines are skipped.
	# Usage:
	#   read_repos "$repositoriesfile" repo_list 
	local file="$1"
	local -n out_array="$2"   # nameref to caller's array
	out_array=()              # ensure empty

	local line trimmed
	while IFS= read -r line || [[ -n $line ]]; do
		# Trim whitespace
		trimmed=$(echo "$line" | xargs)

		# Skip empty line
		[[ -z "$trimmed" ]] && continue

		# Skip line starting with a dot
		[[ $trimmed == .* ]] && continue

		out_array+=("$trimmed")
	done < "$file"
}


# 2. SCRIPT CODE
echo "Installation started ..."
# 1. Handle files
echo "... handling files ..."
handle_file "$REPO_PATH""$LIB_DIR""$classpathfile" true
handle_file "$REPO_PATH""$LIB_DIR""$commonfile" true
handle_file "$REPO_PATH""$BIN_DIR""$abtabfile" true
handle_file "$REPO_PATH""$LIB_DIR""$configfile" false
handle_file "$REPO_PATH""$LIB_DIR""$pathsfile" false
handle_file "$REPO_PATH""$LIB_DIR""$repositoriesfile" false
handle_file "$REPO_PATH""$SCRIPTS_DIR""$requirementsfile" false
handle_file "$REPO_PATH""$LIB_DIR""$versionfile" false

source "$REPO_PATH""$LIB_DIR""$configfile"
ROOT_PATH_="$ROOT_PATH" 
LIB_PATH_="$LIB_PATH"
EXE_PATH_="$EXE_PATH"
GETOPT_PATH_="$GETOPT_PATH"
source "$REPO_PATH""$LIB_DIR""$commonfile"
IS_WIN_="$IS_WIN"
PYTHON_="$PYTHON"

# 2. Configure paths
echo "... configuring paths ... "
check_pathname ROOT_PATH_
# ROOT_PATH_ must be the same as the current working directory, i.e., REPO_PATH
if [[ "$IS_WIN_" == "true" ]]; then
    repo_path="$(convert_win_path "$REPO_PATH")"
else
    repo_path=$REPO_PATH
fi
if [[ "$ROOT_PATH_" != "$repo_path" ]]; then
	echo "Error: As per the README, ROOT_PATH in config.cfg must be set to the current working \
	      directory '$repo_path'. ROOT_PATH is currently set to $ROOT_PATH_." >&2
	exit 1
fi
check_pathname LIB_PATH_
check_pathname EXE_PATH_
if [[ -n "$GETOPT_PATH_" ]]; then # if non-empty
	check_pathname GETOPT_PATH_
fi
# All "*_ROOT" paths are paths newly created in ROOT_PATH. All paths
# are normalised by constructing them from the paths in config.cfg
BIN_PATH_ROOT="$ROOT_PATH_""$BIN_DIR"
check_pathname BIN_PATH_ROOT
LIB_PATH_ROOT="$ROOT_PATH_""$LIB_DIR"
check_pathname LIB_PATH_ROOT
SCRIPTS_PATH_ROOT="$ROOT_PATH_""$SCRIPTS_DIR"
check_pathname SCRIPTS_PATH_ROOT
EXAMPLES_PATH_ROOT="$ROOT_PATH_""$EXAMPLES_DIR"
check_pathname EXAMPLES_PATH_ROOT
DOCS_PATH_ROOT="$ROOT_PATH_""$DOCS_DIR"
check_pathname DOCS_PATH_ROOT
DATA_PATH_ROOT="$ROOT_PATH_""$DATA_DIR"
check_pathname DATA_PATH_ROOT
GIT_PATH_ROOT="$ROOT_PATH_""$GIT_DIR"
check_pathname GIT_PATH_ROOT
LIB_PATH_LIB="$LIB_PATH_""$LIB_DIR"
check_pathname LIB_PATH_LIB
VENV_PATH_LIB="$LIB_PATH_LIB""$VENV_DIR"
check_pathname VENV_PATH_LIB

classpathfile="$LIB_PATH_ROOT""$classpathfile"
commonfile="$LIB_PATH_ROOT""$commonfile"
configfile="$LIB_PATH_ROOT""$configfile"
pathsfile="$LIB_PATH_ROOT""$pathsfile"
repositoriesfile="$LIB_PATH_ROOT""$repositoriesfile"
versionfile="$LIB_PATH_ROOT""$versionfile"
requirementsfile="$SCRIPTS_PATH_ROOT""$requirementsfile"
abtabfile="$BIN_PATH_ROOT""$abtabfile"
gitignorefile="$ROOT_PATH""$gitignorefile"

#echo "SCRIPT_PATH:        " $SCRIPT_PATH
#echo "REPO_PATH:          " $REPO_PATH
#echo
#echo "ROOT_PATH_:         " $ROOT_PATH_
#echo "LIB_PATH_:          " $LIB_PATH_
#echo "EXE_PATH_:          " $EXE_PATH_
#echo "GETOPT_PATH_:       " $GETOPT_PATH_
#echo "BIN_PATH_ROOT:      " $BIN_PATH_ROOT
#echo "LIB_PATH_ROOT:      " $LIB_PATH_ROOT
#echo "SCRIPTS_PATH_ROOT:  " $SCRIPTS_PATH_ROOT
#echo "EXAMPLES_PATH_ROOT: " $EXAMPLES_PATH_ROOT
#echo "DOCS_PATH_ROOT: 	   " DOCS_PATH_ROOT
#echo "DATA_PATH_ROOT:     " $DATA_PATH_ROOT
#echo "GIT_PATH_ROOT:      " $GIT_PATH_ROOT
#echo "LIB_PATH_LIB:       " $LIB_PATH_LIB
#echo "VENV_PATH_LIB:      " $VENV_PATH_LIB
#echo
#echo "classpathfile:      " $classpathfile 
#echo "commonfile:         " $commonfile
#echo "configfile:         " $configfile
#echo "pathsfile:          " $pathsfile
#echo "repositoriesfile:   " $repositoriesfile
#echo "versionfile:        " $versionfile
#echo "requirementsfile:   " $requirementsfile
#echo "abtabfile:          " $abtabfile
#echo "gitignorefile:"     " $gitignorefile

# Set ROOT_PATH_ and LIB_PATH_ in executable
if [[ "$IS_WIN_" == "true" ]]; then
	sed -i "s|$RP_PLACEHOLDER|$ROOT_PATH_|g" "$abtabfile"
	sed -i "s|$LP_PLACEHOLDER|$LIB_PATH_|g" "$abtabfile"
	sed -i "s|$GP_PLACEHOLDER|$GETOPT_PATH_|g" "$abtabfile"
else
	sed -i "" "s|$RP_PLACEHOLDER|$ROOT_PATH_|g" "$abtabfile"
	sed -i "" "s|$LP_PLACEHOLDER|$LIB_PATH_|g" "$abtabfile"
	sed -i "" "s|$GP_PLACEHOLDER|$GETOPT_PATH_|g" "$abtabfile"
fi

# 3. Create directories
echo "... creating directories ... "
# a. Create LIB_PATH_ and EXE_PATH_; create LIB_PATH_LIB
#    - initial abtab installation: paths may exist
#    - abtab update: paths exist
#    If path does not exist: create it
#    If paths exists: remove any existing version(s) of abtab
for pathvar in LIB_PATH_ EXE_PATH_; do
	path="${!pathvar}" # indirect expansion (!) to get the value of the variable pathvar

	# Make sure that path is not a critical system path
	if is_critical_path "$path"; then
		echo "Error: $pathvar $path is a critical system path." >&2
		exit 1
	fi

    if [[ ! -d "$path" ]]; then
        echo "    ... creating $pathvar $path ..."
        mkdir -p "$path"
    else 
        echo "    ... $pathvar $path already exists ..."
        echo "    ... handling existing version of $ABTABNAME ... "
		# LIB_PATH_ case: clear last directory in LIB_PATH_ (abtab/)
		if [[ "$path" == "$LIB_PATH_" ]]; then
			shopt -s nullglob dotglob # ensure that filename expansion (*) includes dotfiles; avoid literal globs
			echo "    ... clearing $pathvar $path ..."
        	rm -rf "$path"*
			shopt -u nullglob dotglob # unset nullglob and dotglob
		# EXE_PATH_ case: remove executable from EXE_PATH_
		else
			file_path="$path$ABTABNAME"
			# Make sure that file_path starts with EXE_PATH_
			if [[ "$file_path" != "$path"* ]]; then
				echo "Error: $file_path is outside the expected path $pathvar $path." >&2
				exit 1
			fi
			# Remove executable
			echo "    ... removing any existing version of $ABTABNAME from $pathvar $path ..."
			rm -f "$file_path"
		fi 
	fi
done
mkdir -p "$LIB_PATH_LIB"
# b. Create DATA_PATH_ROOT subdirectories and move example files into them
#    - initial abtab installation: subdirectories do not exist
#    - abtab update: subdirectories exist (NB it is possible that some are missing)
#    If subdirectory does not exist: create it and copy example files into it
#    If subdirectory exists: keep as-is
for subdir in "${DATA_SUBDIRS[@]}"; do
	subdir_path="$DATA_PATH_ROOT""$subdir"

	if [[ ! -d "$subdir_path" ]]; then
		echo "    ... creating $subdir_path ..."
		mkdir -p "$subdir_path"
		# Copy example files into subdirectory
		# NB Do not use `mv` because of multiple iterations over EXAMPLES_PATH_ROOT 
		shopt -s nullglob dotglob # ensure that filename expansion (*) includes dotfiles; avoid literal globs
		for ex_tab in "$EXAMPLES_PATH_ROOT"*; do
			copy_ex=false
			if [[ "$ex_tab" == *".mid" ]]; then
				 [[ "$subdir" == *"in/MIDI/"* ]] && copy_ex=true
			else
				[[ "$subdir" != *"out/"* && "$subdir" != *"in/MIDI/"*  ]] && copy_ex=true
			fi
			$copy_ex && cp "$ex_tab" "$subdir_path"
		done
		shopt -u nullglob dotglob # unset nullglob and dotglob
	else
		echo "    ... $subdir_path already exists ..."
	fi
done
for item in "$EXAMPLES_PATH_ROOT"*; do
	rm -f "$item"
done

# 4. Clone GitHub repositories
#    - initial abtab installation: do not exist
#    - abtab update: do not exist  
echo "... cloning repositories ... "
declare -a repos
read_reposfile "$repositoriesfile" repos
for repo in "${repos[@]}"; do
	if [[ "$repo" == "models/" || "$repo" == "templates/" ]]; then
		repo_path="$ROOT_PATH_$repo"
	else
		repo_path="$LIB_PATH_LIB$repo"
	fi
	echo "    ... cloning $repo_url ..."
	repo_url="$REPO_URL${repo%/}.git" # without trailing slash
	git clone "$repo_url" "${repo_path%/}" # without trailing slash

	echo "    ... cleaning $repo_path ..."
	shopt -s nullglob dotglob # ensure that filename expansion (*) includes dotfiles
	for item in "$repo_path"*; do        
        item_name=$(basename "$item")

		# models/ repo
		if [[ "$repo" == "models/" ]]; then
			if [[ ! " ${MODELS[*]} " =~ " $item_name " ]]; then # spaces around vars ensure exact word matching
				rm -rf "$item"   
			fi
		# Other repos
		else
			if [[ " ${REMOVE_FROM_REPO[*]} " =~ " ${item_name} " ]] \
			   || [[ "${item_name}" == "$TEMPLATE_PATTERN"*".json" ]]; then # spaces around vars ensure exact word matching 
				rm -rf "$item"
			fi
		fi
	done
	shopt -u nullglob dotglob # unset nullglob and dotglob
	rm -rf "$repo_path$GIT_DIR"
done

# 5. Create virtual environment (in LIB_PATH_LIB); install required packages
echo "... creating virtual environment ..."
"$PYTHON_" -m venv "$VENV_PATH_LIB" || {
	echo "Failed to created venv"
	exit 1
}
if [[ "$IS_WIN_" == "true" ]]; then
	source "$VENV_PATH_LIB""$VENV_SUBDIR_WIN""activate"
else
    source "$VENV_PATH_LIB""$VENV_SUBDIR_UNIX""activate"
fi
echo "    ... installing dependencies ..."
pip install --upgrade pip # pip always exists in activated venv 
pip install -r "$requirementsfile"
deactivate

# 6. Install abtab
echo "... installing $ABTABNAME ..."
# Move files and dirs from ROOT_PATH_
# a. To EXE_PATH_
mv "$abtabfile" "$EXE_PATH_"
# b. To LIB_PATH_
for item in "$LIB_PATH_ROOT"*; do 
	if [[ "$item" == *".sh" ]]; then
		mv "$item" "$LIB_PATH_LIB"
	else
		mv "$item" "$LIB_PATH_"
	fi
done
mv "$SCRIPTS_PATH_ROOT" "$LIB_PATH_"
mv "$DOCS_PATH_ROOT" "$LIB_PATH_"
# Clean up
rm -rf "$GIT_PATH_ROOT"
rm -rf "$BIN_PATH_ROOT" # now empty
rm -rf "$EXAMPLES_PATH_ROOT" # now empty
rm -rf "$LIB_PATH_ROOT" # now empty
rm -f "$gitignorefile"
echo "... installation complete!"
