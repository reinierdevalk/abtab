#!/usr/bin/env bash

# Script that installs abtab.
#
# NB: When editing this file with Sublime, set the line endings to Unix: 
#     View > Line endings > Unix
#
# Directories layout after installation
#
# ROOT_PATH_
# |-- data/
# |-- models/
# |-- templates/
#
# EXE_PATH_/
# |-- abtab
#
# LIB_PATH_/
# |-- docs/
# |   |-- CHANGELOG.md
# |   |-- README.md
# |-- lib/					# runtime code only
# |   |-- .venv/			# virtual environment for Python dependencies
# |   |-- <repo_1-n>		# Java repositories
# |   |-- classpath.sh
# |   |-- common.sh
# |-- scripts/
# |   |-- install
# |   |-- update
# |   |-- requirements.txt
# |-- config.cfg			# auxiliary files
# |-- paths.json
# |-- repositories.txt
# |-- VERSION


# 0. GLOBAL VARIABLES
# a. Set manually
# Variables that have the same value across scripts, but cannot be 
# placed in common.sh because they are needed to call that script
LIB_DIR="lib/"
commonfile="common.sh"
RP_PLACEHOLDER="_RP_PLACEHOLDER_"
LP_PLACEHOLDER="_LP_PLACEHOLDER_"
GP_PLACEHOLDER="_GP_PLACEHOLDER_"

# Directories
BIN_DIR="bin/"
#DATA_DIR="data/"
DOCS_DIR="docs/"
EXAMPLES_DIR="examples/"
GIT_DIR=".git/"
VENV_DIR=".venv/"
VENV_SUBDIR_UNIX="bin/"
VENV_SUBDIR_WIN="Scripts/"
DATA_SUBDIRS=(
	"analyser/in/" "analyser/out/" 
	"converter/" 
	"tabmapper/in/tab/" "tabmapper/in/MIDI/" "tabmapper/out/" 
	"transcriber/diplomatic/in/" "transcriber/polyphonic/in/" 
	"transcriber/diplomatic/out/" "transcriber/polyphonic/out/"
)

# Other
COPY_EXAMPLE_FILES=false
TEMPLATE_PATTERN="template-params-"
REMOVE_FROM_REPO=(
	"src" "test" ".git" ".settings" # folders 
    ".classpath" ".project" ".gitignore" # files
)
MODELS=(
	"N-fwd-thesis-int-4vv" 
	"N-bwd-thesis-int-4vv" 
	"D-bwd-thesis-int-4vv"
)

# b. Set automatically 
SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)""/" # the absolute path of the current script (.../scripts/)
REPO_PATH="$(cd "$SCRIPT_PATH/.." && pwd)""/" # the path holding scripts/


# 1. FUNCTIONS
normalise_path() {
	# Normalises a filesystem path for reliable cross-platform comparison.
	#
	# Accepts:
	# - Windows paths: C:/dir/ or C:\dir\
	# - Cygwin paths:  /cygdrive/c/dir/
	# - macOS/Linux:   /Users/name/dir/
	#
	# Output:
	# - Prints the normalized path (string) to stdout

	local p="$1"

	# Convert Cygwin paths to Windows-style paths if `cygpath` is available
	if command -v cygpath >/dev/null 2>&1; then
		p=$(cygpath -m "$p" 2>/dev/null || echo "$p")
	fi

	# Convert backslashes to forward slashes
	p="${p//\\//}"

	# Remove duplicate slashes
	while [[ "$p" == *"//"* ]]; do
		p="${p//\/\//\/}"
	done

	# Ensure exactly one trailing slash
	p="${p%/}/"
}

#convert_win_path() {
#    #Normalizes a filesystem path for consistent cross-platform comparison.
#    #
#    # Parameters:
#    # p (string): The input path to normalise. Can be in one of the following forms:
#    # - macOS/Linux POSIX path: "/Users/<name>/dir_x/"
#    # - Windows path: "C:/Users/<name>/dir_x/" or "C:\Users\<name>\dir_x\"
#    # - Cygwin path: "/cygdrive/c/Users/<name>/dir_x/"
#    #
#    # Behavior:
#    # - Converts backslashes (\) to forward slashes (/).
#    # - Removes duplicate consecutive slashes.
#    # - Ensures the path ends with a single trailing slash.
#    # - On Cygwin, converts POSIX-style (/cygdrive/<drive>/) paths to Windows-style
#    #   drive paths (e.g., "F:/path") using cygpath -m.
#    #
#    # Returns:
#    # Normalised path as a string suitable for reliable string comparison.
#    #
#    # Example:
#    # $ FILE_PATH_RAW="/cygdrive/f/research/computation/software/"
#    # $ FILE_PATH=$(normalize_path "$FILE_PATH_RAW")
#    # $ echo "$FILE_PATH"  # Output: "F:/research/computation/software/"
#
#    local p="$1"
#    cygpath -m "$p" 2>/dev/null || echo "$p"
#}

#handle_file() {
#    local file="$1"
#    local make_executable="$2"
#    # If the file exists, handle it
#    if [[ -f "$file" ]]; then
#        # Remove any carriage returns
#        # All line endings in a script called by bash must be Unix style ('\n') 
#        # and not Windows style ('\r\n'), which cause the following error:
#        # 
#        #   ./<my_script>.sh: line <n>: $'\r': command not found
#        #    
#        # Any carriage returns ('\r') must therefore be removed.
#        #
#        # NB: Carriage returns can be avoided by creating the file in Sublime 4,
#        # after adding the following in the right field at Preferences > Settings:
#        #
#        #   {
#        #    "default_line_ending": "unix"
#        #   }
#        _remove_carriage_returns "$file"
#
#        # Make executable (if applicable)
#        if [[ "$make_executable" == "true" ]]; then
#            chmod +x "$file"
#        fi
#    # If not, return error
#    else
#        echo "File not found: $file."
#        exit 1
#    fi
#}

#_remove_carriage_returns() {
#    local file="$1"
#    if grep -q $'\r' "$file"; then
#        tr -d '\r' <"$file" >file.new && mv file.new "$file"
#    fi
#}

#check_pathname() {
#	# Checks that the given path name is not unset/empty, 
#	# and that it ends with a slash.
#	
#	local pathname="$1"
#	declare -n ref="$pathname" # nameref to the actual variable
#
#	# Check that variable is set and non-empty
#	if [[ -z "$ref" ]]; then
#		echo "Error: $pathname is not set or empty." >&2
#		exit 1
#	fi
#
#	# Ensure that variable ends with a slash
#	if [[ "${ref: -1}" != "/" ]]; then
#		ref="${ref}/"
#	fi
#}

is_critical_path() {
	local path="$1"

	# Empty or root
	[[ -z "$path" || "$path" == "/" ]] && return 0

	# Unix critical directories: start with /bin, /usr, /etc, /lib, /home
	if [[ "$path" == /bin* || "$path" == /sbin* || "$path" == /usr* || \
		  "$path" == /etc* || "$path" == /lib* || "$path" == /home* ]]; then
		return 0
	fi

	# Windows (Cygwin/Git Bash) critical directories: anything under /cygdrive/c
	if [[ "$path" == /cygdrive/c* ]]; then
		return 0
	fi

	return 1
}

read_reposfile() {
	# Reads a text file and returns an array containing its individual 
	# lines (including any trailing slash). Empty lines are skipped.
	# Usage:
	#   read_repos "$repositoriesfile" repo_list 
	local file="$1"
	local -n out_array="$2"   # nameref to caller's array
	out_array=()              # ensure empty

	local line trimmed
	while IFS= read -r line || [[ -n $line ]]; do
		# Trim whitespace
		trimmed=$(echo "$line" | xargs)

		# Skip empty line
		[[ -z "$trimmed" ]] && continue

		# Skip line starting with a dot
		[[ $trimmed == .* ]] && continue

		out_array+=("$trimmed")
	done < "$file"
}


# 2. SCRIPT CODE
echo "Installation started ..."
# 1. Handle files
# NB It is assumed that commonfile itself does not need to be handled
echo "... handling files ..."
#handle_file "$REPO_PATH""$LIB_DIR""$commonfile" true
source "$REPO_PATH""$LIB_DIR""$commonfile"
ABTABNAME_="$ABTABNAME"
GITHUB_URL_="$GITHUB_URL"
DATA_DIR_="$DATA_DIR"
MODELS_DIR_="$MODELS_DIR"
SCRIPTS_DIR_="$SCRIPTS_DIR"
TEMPLATES_DIR_="$TEMPLATES_DIR"
TMP_DIR_="$TMP_DIR"
abtabfile_="$abtabfile"
classpathfile_="$classpathfile"
configfile_="$configfile"
gitignorefile_="$gitignorefile"
pathsfile_="$pathsfile"
repositoriesfile_="$repositoriesfile"
requirementsfile_="$requirementsfile"
updatefile_="$updatefile"
versionfile_="$versionfile"
IS_WIN_="$IS_WIN"
PYTHON_="$PYTHON"
handle_file "$REPO_PATH""$BIN_DIR""$abtabfile_" true
handle_file "$REPO_PATH""$LIB_DIR""$classpathfile_" true
handle_file "$REPO_PATH""$LIB_DIR""$configfile_" false
handle_file "$REPO_PATH""$gitignorefile_" false
handle_file "$REPO_PATH""$LIB_DIR""$pathsfile_" false
handle_file "$REPO_PATH""$LIB_DIR""$repositoriesfile_" false
handle_file "$REPO_PATH""$SCRIPTS_DIR_""$requirementsfile_" false
handle_file "$REPO_PATH""$SCRIPTS_DIR_""$updatefile_" true
handle_file "$REPO_PATH""$LIB_DIR""$versionfile_" false

# 2. Configure paths
# All paths are normalised by constructing them from the base paths
echo "... configuring paths ... "
# a. Base paths
source "$REPO_PATH""$LIB_DIR""$configfile_"
ROOT_PATH_="$ROOT_PATH"
LIB_PATH_="$LIB_PATH"
EXE_PATH_="$EXE_PATH"
GETOPT_PATH_="$GETOPT_PATH"
# b. Paths on ROOT_PATH_
BIN_PATH_ROOT="$ROOT_PATH_""$BIN_DIR"
DATA_PATH_ROOT="$ROOT_PATH_""$DATA_DIR_"
DOCS_PATH_ROOT="$ROOT_PATH_""$DOCS_DIR"
#EXAMPLES_PATH_ROOT="$ROOT_PATH_""$EXAMPLES_DIR"
GIT_PATH_ROOT="$ROOT_PATH_""$GIT_DIR"
LIB_PATH_ROOT="$ROOT_PATH_""$LIB_DIR"
SCRIPTS_PATH_ROOT="$ROOT_PATH_""$SCRIPTS_DIR_"
# c. Paths on LIB_PATH_
LIB_PATH_LIB="$LIB_PATH_""$LIB_DIR"
LIB_PATH_TMP="$LIB_PATH_""$TMP_DIR_"
VENV_PATH_LIB="$LIB_PATH_LIB""$VENV_DIR"
check_pathname ROOT_PATH_
check_pathname LIB_PATH_
check_pathname EXE_PATH_
if [[ -n "$GETOPT_PATH_" ]]; then # if non-empty
	check_pathname GETOPT_PATH_
fi
check_pathname BIN_PATH_ROOT
check_pathname DATA_PATH_ROOT
check_pathname DOCS_PATH_ROOT
#check_pathname EXAMPLES_PATH_ROOT
check_pathname GIT_PATH_ROOT
check_pathname LIB_PATH_ROOT
check_pathname SCRIPTS_PATH_ROOT
check_pathname LIB_PATH_LIB
check_pathname LIB_PATH_TMP
check_pathname VENV_PATH_LIB
# Check that ROOT_PATH_ is the same as the current working directory (REPO_PATH)
repo_path="$(normalise_path "$REPO_PATH")"
if [[ "$ROOT_PATH_" != "$repo_path" ]]; then
	echo "Error: As per the README, ROOT_PATH in $configfile_ must be set to the current working \
	      directory $repo_path. ROOT_PATH is currently set to $ROOT_PATH_." >&2
	exit 1
fi

# Set full path for files needed in this script
abtabfile_="$BIN_PATH_ROOT""$abtabfile_"
gitignorefile_="$ROOT_PATH_""$gitignorefile_"
repositoriesfile_="$LIB_PATH_ROOT""$repositoriesfile_"
requirementsfile_="$SCRIPTS_PATH_ROOT""$requirementsfile_"

# 3. Set ROOT_PATH_ and LIB_PATH_ in executable
if [[ "$IS_WIN_" == "true" ]]; then
	sed -i "s|$RP_PLACEHOLDER|$ROOT_PATH_|g" "$abtabfile_"
	sed -i "s|$LP_PLACEHOLDER|$LIB_PATH_|g" "$abtabfile_"
	sed -i "s|$GP_PLACEHOLDER|$GETOPT_PATH_|g" "$abtabfile_"
else
	sed -i "" "s|$RP_PLACEHOLDER|$ROOT_PATH_|g" "$abtabfile_"
	sed -i "" "s|$LP_PLACEHOLDER|$LIB_PATH_|g" "$abtabfile_"
	sed -i "" "s|$GP_PLACEHOLDER|$GETOPT_PATH_|g" "$abtabfile_"
fi

# 4. Create directories
echo "... creating directories ... "
# a. Create LIB_PATH_ and EXE_PATH_; create LIB_PATH_LIB
#    - initial abtab installation: paths may exist
#    - abtab update: paths exist
#    If path does not exist: create it
#    If paths exists: remove any existing version(s) of abtab
for pathvar in LIB_PATH_ EXE_PATH_; do
	path="${!pathvar}" # indirect expansion (!) to get the value of the variable pathvar

	# Make sure that path is not a critical system path
	if is_critical_path "$path"; then
		echo "Error: $pathvar $path is a critical system path." >&2
		exit 1
	fi

    if [[ ! -d "$path" ]]; then
        echo "    ... creating $pathvar $path ..."
        mkdir -p "$path"
    else 
        echo "    ... $pathvar $path already exists ..."
        echo "    ... handling existing version of $ABTABNAME_ ... "
		# LIB_PATH_ case: clear last directory in LIB_PATH_ (abtab/)
		if [[ "$path" == "$LIB_PATH_" ]]; then
			shopt -s nullglob dotglob # ensure that filename expansion (*) includes dotfiles; avoid literal globs
			echo "    ... clearing $pathvar $path ..."
			# In the update case, do not delete TMP_DIR
			for item in "$path"*; do
				[[ "$item/" == "$LIB_PATH_TMP" ]] && continue # add slash after item because glob returns dir names w/o trailing slash
				rm -rf "$item"
			done
#			rm -rf "$path"*
			shopt -u nullglob dotglob # unset nullglob and dotglob
		# EXE_PATH_ case: remove executable from EXE_PATH_
		else
			file_path="$path$ABTABNAME_"
			# Make sure that file_path starts with EXE_PATH_
			if [[ "$file_path" != "$path"* ]]; then
				echo "Error: $file_path is outside the expected path $pathvar $path." >&2
				exit 1
			fi
			# Remove executable
			echo "    ... removing any existing version of $ABTABNAME_ from $pathvar $path ..."
			rm -f "$file_path"
		fi 
	fi
done
mkdir -p "$LIB_PATH_LIB"
# b. Create DATA_PATH_ROOT subdirectories
#    - initial abtab installation: subdirectories do not exist
#    - abtab update: subdirectories exist (NB it is possible that some are missing)
#    If subdirectory does not exist: create it
#    If subdirectory exists: keep as-is
for subdir in "${DATA_SUBDIRS[@]}"; do
	subdir_path="$DATA_PATH_ROOT""$subdir"

	if [[ ! -d "$subdir_path" ]]; then
		echo "    ... creating $subdir_path ..."
		mkdir -p "$subdir_path"
		# Copy example files into subdirectory
		if [[ "$COPY_EXAMPLE_FILES" == "true" ]]; then
			# NB Do not use `mv` because of multiple iterations over EXAMPLES_PATH_ROOT 
			shopt -s nullglob dotglob # ensure that filename expansion (*) includes dotfiles; avoid literal globs
			for ex_tab in "$EXAMPLES_PATH_ROOT"*; do
				copy_ex=false
				if [[ "$ex_tab" == *".mid" ]]; then
					 [[ "$subdir" == *"in/MIDI/"* ]] && copy_ex=true
				else
					[[ "$subdir" != *"out/"* && "$subdir" != *"in/MIDI/"*  ]] && copy_ex=true
				fi
				$copy_ex && cp "$ex_tab" "$subdir_path"
			done
			shopt -u nullglob dotglob # unset nullglob and dotglob
		fi
	else
		echo "    ... $subdir_path already exists ..."
	fi
done
#for item in "$EXAMPLES_PATH_ROOT"*; do
#	rm -f "$item"
#done

# 5. Clone GitHub repositories
#    - initial abtab installation: do not exist
#    - abtab update: do not exist  
echo "... cloning repositories ... "
declare -a repos
read_reposfile "$repositoriesfile_" repos
for repo in "${repos[@]}"; do
	if [[ "$repo" == "$MODELS_DIR_" || "$repo" == "$TEMPLATES_DIR_" ]]; then
		repo_path="$ROOT_PATH_$repo"
	else
		repo_path="$LIB_PATH_LIB$repo"
	fi
	echo "    ... cloning $repo_url ..."
	repo_url="$GITHUB_URL_${repo%/}.git" # without trailing slash
	git clone "$repo_url" "${repo_path%/}" # without trailing slash

	echo "    ... cleaning $repo_path ..."
	shopt -s nullglob dotglob # ensure that filename expansion (*) includes dotfiles; avoid literal globs
	for item in "$repo_path"*; do        
        item_name=$(basename "$item")

		# models/ repo
		if [[ "$repo" == "$MODELS_DIR_" ]]; then
			if [[ ! " ${MODELS[*]} " =~ " $item_name " ]]; then # spaces around vars ensure exact word matching
				rm -rf "$item"   
			fi
		# Other repos
		else
			if [[ " ${REMOVE_FROM_REPO[*]} " =~ " ${item_name} " ]] \
			   || [[ "${item_name}" == "$TEMPLATE_PATTERN"*".json" ]]; then # spaces around vars ensure exact word matching 
				rm -rf "$item"
			fi
		fi
	done
	shopt -u nullglob dotglob # unset nullglob and dotglob
	rm -rf "$repo_path$GIT_DIR"
done

# 6. Create virtual environment (in LIB_PATH_LIB); install required packages
echo "... creating virtual environment ..."
"$PYTHON_" -m venv "$VENV_PATH_LIB" || {
	echo "Failed to created venv"
	exit 1
}
if [[ "$IS_WIN_" == "true" ]]; then
	source "$VENV_PATH_LIB""$VENV_SUBDIR_WIN""activate"
else
    source "$VENV_PATH_LIB""$VENV_SUBDIR_UNIX""activate"
fi
echo "    ... installing dependencies ..."
pip install --upgrade pip # pip always exists in activated venv 
pip install -r "$requirementsfile_"
deactivate

# 7. Install abtab
echo "... installing $ABTABNAME_ ..."
# Move files and dirs from ROOT_PATH_
# a. To EXE_PATH_
mv "$abtabfile_" "$EXE_PATH_"
# b. To LIB_PATH_
for item in "$LIB_PATH_ROOT"*; do 
	if [[ "$item" == *".sh" ]]; then
		mv "$item" "$LIB_PATH_LIB"
	else
		mv "$item" "$LIB_PATH_"
	fi
done
mv "$SCRIPTS_PATH_ROOT" "$LIB_PATH_"
mv "$DOCS_PATH_ROOT" "$LIB_PATH_"
# Clean up
rm -rf "$GIT_PATH_ROOT"
rm -rf "$BIN_PATH_ROOT" # now empty
#rm -rf "$EXAMPLES_PATH_ROOT" # now empty
rm -rf "$LIB_PATH_ROOT" # now empty
rm -f "$gitignorefile_"
echo "... installation complete!"